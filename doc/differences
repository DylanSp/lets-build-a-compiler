Differences from tutorial:

Stream processing:
-No lookahead variable; use peek() instead
-No separate GetChar() function; use get() instead

Char/string processing:
-No separate isNum(), isAlpha(), isAlNum() functions; use native functions from cctype
-compile_intermediate() handles a single line (read into a stringstream), compile_full() handles a vector of lines. 
-Separation by newlines is handled by a driver program (interactive_compiler, full_compiler, test_generator).

Special characters are recognized by membership in std::unordered_set, with aid of the is_in() helper method.

Variables are looked up in a std::map.

Registers are simulated by an array

Functions:
-Functions are defined as empty lambdas, don't actually do anything. 
-if they're part of an assignment, variable gets value of register 0.

Grammar:
-Numeric literals can't begin with 0, to avoid inadvertent use of C++ octal literals.

Chapter 6:
-boolean true is encoded as 1 in registers
-boolean_factor sets cond based on cpu_registers[0] in case of boolean literals

Block processing/control flow:
-instead of END statement, have "return;"
-condition flags are tracked by a boolean, "cond"
-ELSE_CHAR added to BLOCK_ENDS so block() stops properly
-for statement uses cpu_variables[counter_name] instead of LEA-addressed memory
-reworked do statement completely, avoiding dbra instruction and associated bugs
-Note: loop statements with no break will produce a compiler warning for an unused label
-each line must end with an END_CHAR (which gets match()'d by program())
-fin() for skipping newlines isn't needed; compile_full loops through lines, supplies each line to compile_intermediate
-post_label emits a label followed by a semicolon to make a complete statement; necessary when label is at end of a block (test with "i1=2x=1lx=2ee")

Chapter 5's other() function produces code echoing get_name() to std::cout
Chapter 5's condition() statement sets cond = true
Chapter 5's expression() statement sets cpu_registers[0] = 0
